<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Directed Graph Viewer</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #graph {
            width: 100%;
            height: 100%;
        }
        .node {
            fill: white;
            stroke: black;
            stroke-width: 2;
        }
        .node-medoid {
            stroke: #4CAF50;  /* Green */
        }
        .node-hover {
            fill: #e6e6fa; /* Lavender */
            stroke: #8a2be2; /* Blue Violet */
        }
        .node-label {
            font-family: Arial, sans-serif;
            font-size: 12px;
            fill: black;
            pointer-events: none;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1;
            stroke-dasharray: 4;
        }
        .neighbor-highlight {
            stroke: #ff9800;
            stroke-width: 2;
            stroke-dasharray: none;
        }
        .knn-highlight {
            stroke: #2196F3;
            stroke-width: 2;
            stroke-dasharray: none;
        }
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
            white-space: pre-wrap;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <svg id="graph"></svg>
    <div id="tooltip" class="tooltip" style="display: none;"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script type="module">
        const graphData = await fetch("./target/vamana-test-dump.json").then(res => res.json());

        const svg = d3.select('#graph');
        const width = window.innerWidth;
        const height = window.innerHeight;
        let zoom = d3.zoom().on('zoom', handleZoom);

        svg.call(zoom);

        const g = svg.append('g');
        const tooltip = d3.select('#tooltip');

        function handleZoom(e) {
            g.attr('transform', e.transform);
        }

        function updateGraph() {
            const links = g.selectAll('.link')
                .data(graphData.nodes.flatMap(node =>
                    node.neighbors.map(neighborId => ({
                        source: node,
                        target: graphData.nodes.find(n => n.id === neighborId)
                    }))
                ))
                .join('line')
                .attr('class', 'link')
                .attr('x1', d => d.source.point[0])
                .attr('y1', d => d.source.point[1])
                .attr('x2', d => d.target.point[0])
                .attr('y2', d => d.target.point[1]);

            const nodes = g.selectAll('.node')
                .data(graphData.nodes)
                .join('g')
                .attr('class', d => `node ${d.id === graphData.medoid ? 'node-medoid' : ''}`)
                .attr('transform', d => `translate(${d.point[0]},${d.point[1]})`)
                .on('mouseover', handleNodeHover)
                .on('mouseout', handleNodeUnhover);

            nodes.append('circle')
                .attr('r', 15)
                .attr('fill', 'white')
                .attr('stroke', d => d.id === graphData.medoid ? '#4CAF50' : 'black')
                .attr('stroke-width', 2);

            nodes.append('text')
                .attr('class', 'node-label')
                .attr('text-anchor', 'middle')
                .attr('dy', '0.35em')
                .text(d => d.id);

            // Adjust edge endpoints
            links.each(function(d) {
                const dx = d.target.point[0] - d.source.point[0];
                const dy = d.target.point[1] - d.source.point[1];
                const angle = Math.atan2(dy, dx);
                const nodeRadius = 15;

                const sourceX = d.source.point[0] + nodeRadius * Math.cos(angle);
                const sourceY = d.source.point[1] + nodeRadius * Math.sin(angle);
                const targetX = d.target.point[0] - nodeRadius * Math.cos(angle);
                const targetY = d.target.point[1] - nodeRadius * Math.sin(angle);

                d3.select(this)
                    .attr('x1', sourceX)
                    .attr('y1', sourceY)
                    .attr('x2', targetX)
                    .attr('y2', targetY);
            });
        }

        function handleNodeHover(event, d) {
            const node = d3.select(this);
            node.select('circle').attr('fill', '#e6e6fa').attr('stroke', '#8a2be2');

            const neighborSet = new Set(d.neighbors);
            const knnSet = new Set(d.knn);

            g.selectAll('.node').each(function(otherNode) {
                if (otherNode.id === d.id) return; // Skip the hovered node

                const isNeighbor = neighborSet.has(otherNode.id);
                const isKnn = knnSet.has(otherNode.id);

                if (isNeighbor && isKnn) {
                    d3.select(this).select('circle')
                        .attr('fill', 'url(#split-fill-' + otherNode.id + ')');

                    // Create a linear gradient for split fill
                    const gradient = svg.append('defs')
                        .append('linearGradient')
                        .attr('id', 'split-fill-' + otherNode.id)
                        .attr('x1', '0%').attr('y1', '0%')
                        .attr('x2', '100%').attr('y2', '0%');

                    gradient.append('stop')
                        .attr('offset', '50%')
                        .attr('stop-color', '#ff9800');

                    gradient.append('stop')
                        .attr('offset', '50%')
                        .attr('stop-color', '#2196F3');
                } else if (isNeighbor) {
                    d3.select(this).select('circle').attr('fill', '#ff9800');
                } else if (isKnn) {
                    d3.select(this).select('circle').attr('fill', '#2196F3');
                }
            });

            g.selectAll('.link')
                .filter(link => link.source.id === d.id && neighborSet.has(link.target.id))
                .classed('neighbor-highlight', true);

            // Show tooltip
            // tooltip.style('display', 'block')
            //     .style('left', (event.pageX + 10) + 'px')
            //     .style('top', (event.pageY + 10) + 'px')
            //     .text(JSON.stringify(d, null, 2));
        }

        function handleNodeUnhover() {
            g.selectAll('.node circle')
                .attr('fill', 'white')
                .attr('stroke', function(d) {
                    return d.id === graphData.medoid ? '#4CAF50' : 'black';
                });

            g.selectAll('.link')
                .classed('neighbor-highlight', false)
                .classed('knn-highlight', false);

            // Remove all gradients
            svg.selectAll('defs').remove();

            // Hide tooltip
            tooltip.style('display', 'none');
        }

        updateGraph();

        window.addEventListener('resize', () => {
            svg.attr('width', window.innerWidth).attr('height', window.innerHeight);
        });
    </script>
</body>
</html>
